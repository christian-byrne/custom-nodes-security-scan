
<!DOCTYPE html>
<html>
<head>

<meta charset="UTF-8">

<title>
    Bandit Report
</title>

<style>

html * {
    font-family: "Arial", sans-serif;
}

pre {
    font-family: "Monaco", monospace;
}

.bordered-box {
    border: 1px solid black;
    padding-top:.5em;
    padding-bottom:.5em;
    padding-left:1em;
}

.metrics-box {
    font-size: 1.1em;
    line-height: 130%;
}

.metrics-title {
    font-size: 1.5em;
    font-weight: 500;
    margin-bottom: .25em;
}

.issue-description {
    font-size: 1.3em;
    font-weight: 500;
}

.candidate-issues {
    margin-left: 2em;
    border-left: solid 1px; LightGray;
    padding-left: 5%;
    margin-top: .2em;
    margin-bottom: .2em;
}

.issue-block {
    border: 1px solid LightGray;
    padding-left: .5em;
    padding-top: .5em;
    padding-bottom: .5em;
    margin-bottom: .5em;
}

.issue-sev-high {
    background-color: Pink;
}

.issue-sev-medium {
    background-color: NavajoWhite;
}

.issue-sev-low {
    background-color: LightCyan;
}

</style>
</head>

<body>

<div id="metrics">
    <div class="metrics-box bordered-box">
        <div class="metrics-title">
            Metrics:<br>
        </div>
        Total lines of code: <span id="loc">1710</span><br>
        Total lines skipped (#nosec): <span id="nosec">0</span>
    </div>
</div>




<br>
<div id="results">
    
<div id="issue-0">
<div class="issue-block issue-sev-low">
    <b>blacklist: </b> Consider possible security implications associated with the subprocess module.<br>
    <b>Test ID:</b> B404<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py</a><br>
    <b>Line number: </b>4<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/blacklists/blacklist_imports.html#b404-import-subprocess" target="_blank">https://bandit.readthedocs.io/en/1.7.9/blacklists/blacklist_imports.html#b404-import-subprocess</a><br>

<div class="code">
<pre>
1	import os
2	import sys
3	import json
4	import subprocess
5	import numpy as np
6	import re
7	import datetime
8	from typing import List
9	import torch
10	from PIL import Image, ExifTags
11	from PIL.PngImagePlugin import PngInfo
12	from pathlib import Path
13	
14	import folder_paths
15	from .logger import logger
16	from .image_latent_nodes import *
17	from .load_video_nodes import LoadVideoUpload, LoadVideoPath
18	from .load_images_nodes import LoadImagesFromDirectoryUpload, LoadImagesFromDirectoryPath
19	from .batched_nodes import VAEEncodeBatched, VAEDecodeBatched
20	from .utils import ffmpeg_path, get_audio, hash_path, validate_path, requeue_workflow, gifski_path, calculate_file_hash
21	
22	folder_paths.folder_names_and_paths[&quot;VHS_video_formats&quot;] = (
23	    [
24	        os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;..&quot;, &quot;video_formats&quot;),
25	    ],
26	    [&quot;.json&quot;]
27	)
28	audio_extensions = [&#x27;mp3&#x27;, &#x27;mp4&#x27;, &#x27;wav&#x27;, &#x27;ogg&#x27;]
29	
30	def gen_format_widgets(video_format):
31	    for k in video_format:
32	        if k.endswith(&quot;_pass&quot;):
33	            for i in range(len(video_format[k])):
34	                if isinstance(video_format[k][i], list):
35	                    item = [video_format[k][i]]
36	                    yield item
37	                    video_format[k][i] = item[0]
38	        else:
39	            if isinstance(video_format[k], list):
40	                item = [video_format[k]]
41	                yield item
42	                video_format[k] = item[0]
43	
44	def get_video_formats():
45	    formats = []
46	    for format_name in folder_paths.get_filename_list(&quot;VHS_video_formats&quot;):
47	        format_name = format_name[:-5]
48	        video_format_path = folder_paths.get_full_path(&quot;VHS_video_formats&quot;, format_name + &quot;.json&quot;)
49	        with open(video_format_path, &#x27;r&#x27;) as stream:
50	            video_format = json.load(stream)
51	        if &quot;gifski_pass&quot; in video_format and gifski_path is None:
52	            #Skip format
53	            continue
54	        widgets = [w[0] for w in gen_format_widgets(video_format)]
55	        if (len(widgets) &gt; 0):
56	            formats.append([&quot;video/&quot; + format_name, widgets])
57	        else:
58	            formats.append(&quot;video/&quot; + format_name)
59	    return formats
60	
61	def get_format_widget_defaults(format_name):
62	    video_format_path = folder_paths.get_full_path(&quot;VHS_video_formats&quot;, format_name + &quot;.json&quot;)
63	    with open(video_format_path, &#x27;r&#x27;) as stream:
64	        video_format = json.load(stream)
65	    results = {}
66	    for w in gen_format_widgets(video_format):
67	        if len(w[0]) &gt; 2 and &#x27;default&#x27; in w[0][2]:
68	            default = w[0][2][&#x27;default&#x27;]
69	        else:
70	            if type(w[0][1]) is list:
71	                default = w[0][1][0]
72	            else:
73	                #NOTE: This doesn&#x27;t respect max/min, but should be good enough as a fallback to a fallback to a fallback
74	                default = {&quot;BOOLEAN&quot;: False, &quot;INT&quot;: 0, &quot;FLOAT&quot;: 0, &quot;STRING&quot;: &quot;&quot;}[w[0][1]]
75	        results[w[0][0]] = default
76	    return results
77	
78	
79	def apply_format_widgets(format_name, kwargs):
80	    video_format_path = folder_paths.get_full_path(&quot;VHS_video_formats&quot;, format_name + &quot;.json&quot;)
81	    with open(video_format_path, &#x27;r&#x27;) as stream:
82	        video_format = json.load(stream)
83	    for w in gen_format_widgets(video_format):
84	        assert(w[0][0] in kwargs)
85	        w[0] = str(kwargs[w[0][0]])
86	    return video_format
87	
88	def tensor_to_int(tensor, bits):
89	    #TODO: investigate benefit of rounding by adding 0.5 before clip/cast
90	    tensor = tensor.cpu().numpy() * (2**bits-1)
91	    return np.clip(tensor, 0, (2**bits-1))
92	def tensor_to_shorts(tensor):
93	    return tensor_to_int(tensor, 16).astype(np.uint16)
94	def tensor_to_bytes(tensor):
95	    return tensor_to_int(tensor, 8).astype(np.uint8)
96	
97	def ffmpeg_process(args, video_format, video_metadata, file_path, env):
98	
99	    res = None
100	    frame_data = yield
101	    if video_format.get(&#x27;save_metadata&#x27;, &#x27;False&#x27;) != &#x27;False&#x27;:
102	        os.makedirs(folder_paths.get_temp_directory(), exist_ok=True)
103	        metadata = json.dumps(video_metadata)
104	        metadata_path = os.path.join(folder_paths.get_temp_directory(), &quot;metadata.txt&quot;)
105	        #metadata from file should  escape = ; # \ and newline
106	        metadata = metadata.replace(&quot;\\&quot;,&quot;\\\\&quot;)
107	        metadata = metadata.replace(&quot;;&quot;,&quot;\\;&quot;)
108	        metadata = metadata.replace(&quot;#&quot;,&quot;\\#&quot;)
109	        metadata = metadata.replace(&quot;=&quot;,&quot;\\=&quot;)
110	        metadata = metadata.replace(&quot;\n&quot;,&quot;\\\n&quot;)
111	        metadata = &quot;comment=&quot; + metadata
112	        with open(metadata_path, &quot;w&quot;) as f:
113	            f.write(&quot;;FFMETADATA1\n&quot;)
114	            f.write(metadata)
115	        m_args = args[:1] + [&quot;-i&quot;, metadata_path] + args[1:] + [&quot;-metadata&quot;, &quot;creation_time=now&quot;]
116	        with subprocess.Popen(m_args + [file_path], stderr=subprocess.PIPE,
117	                              stdin=subprocess.PIPE, env=env) as proc:
118	            try:
119	                while frame_data is not None:
120	                    proc.stdin.write(frame_data)
</pre>
</div>


</div>
</div>

<div id="issue-1">
<div class="issue-block issue-sev-low">
    <b>subprocess_without_shell_equals_true: </b> subprocess call - check for execution of untrusted input.<br>
    <b>Test ID:</b> B603<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py</a><br>
    <b>Line number: </b>116<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html</a><br>

<div class="code">
<pre>
56	            formats.append([&quot;video/&quot; + format_name, widgets])
57	        else:
58	            formats.append(&quot;video/&quot; + format_name)
59	    return formats
60	
61	def get_format_widget_defaults(format_name):
62	    video_format_path = folder_paths.get_full_path(&quot;VHS_video_formats&quot;, format_name + &quot;.json&quot;)
63	    with open(video_format_path, &#x27;r&#x27;) as stream:
64	        video_format = json.load(stream)
65	    results = {}
66	    for w in gen_format_widgets(video_format):
67	        if len(w[0]) &gt; 2 and &#x27;default&#x27; in w[0][2]:
68	            default = w[0][2][&#x27;default&#x27;]
69	        else:
70	            if type(w[0][1]) is list:
71	                default = w[0][1][0]
72	            else:
73	                #NOTE: This doesn&#x27;t respect max/min, but should be good enough as a fallback to a fallback to a fallback
74	                default = {&quot;BOOLEAN&quot;: False, &quot;INT&quot;: 0, &quot;FLOAT&quot;: 0, &quot;STRING&quot;: &quot;&quot;}[w[0][1]]
75	        results[w[0][0]] = default
76	    return results
77	
78	
79	def apply_format_widgets(format_name, kwargs):
80	    video_format_path = folder_paths.get_full_path(&quot;VHS_video_formats&quot;, format_name + &quot;.json&quot;)
81	    with open(video_format_path, &#x27;r&#x27;) as stream:
82	        video_format = json.load(stream)
83	    for w in gen_format_widgets(video_format):
84	        assert(w[0][0] in kwargs)
85	        w[0] = str(kwargs[w[0][0]])
86	    return video_format
87	
88	def tensor_to_int(tensor, bits):
89	    #TODO: investigate benefit of rounding by adding 0.5 before clip/cast
90	    tensor = tensor.cpu().numpy() * (2**bits-1)
91	    return np.clip(tensor, 0, (2**bits-1))
92	def tensor_to_shorts(tensor):
93	    return tensor_to_int(tensor, 16).astype(np.uint16)
94	def tensor_to_bytes(tensor):
95	    return tensor_to_int(tensor, 8).astype(np.uint8)
96	
97	def ffmpeg_process(args, video_format, video_metadata, file_path, env):
98	
99	    res = None
100	    frame_data = yield
101	    if video_format.get(&#x27;save_metadata&#x27;, &#x27;False&#x27;) != &#x27;False&#x27;:
102	        os.makedirs(folder_paths.get_temp_directory(), exist_ok=True)
103	        metadata = json.dumps(video_metadata)
104	        metadata_path = os.path.join(folder_paths.get_temp_directory(), &quot;metadata.txt&quot;)
105	        #metadata from file should  escape = ; # \ and newline
106	        metadata = metadata.replace(&quot;\\&quot;,&quot;\\\\&quot;)
107	        metadata = metadata.replace(&quot;;&quot;,&quot;\\;&quot;)
108	        metadata = metadata.replace(&quot;#&quot;,&quot;\\#&quot;)
109	        metadata = metadata.replace(&quot;=&quot;,&quot;\\=&quot;)
110	        metadata = metadata.replace(&quot;\n&quot;,&quot;\\\n&quot;)
111	        metadata = &quot;comment=&quot; + metadata
112	        with open(metadata_path, &quot;w&quot;) as f:
113	            f.write(&quot;;FFMETADATA1\n&quot;)
114	            f.write(metadata)
115	        m_args = args[:1] + [&quot;-i&quot;, metadata_path] + args[1:] + [&quot;-metadata&quot;, &quot;creation_time=now&quot;]
116	        with subprocess.Popen(m_args + [file_path], stderr=subprocess.PIPE,
117	                              stdin=subprocess.PIPE, env=env) as proc:
118	            try:
119	                while frame_data is not None:
120	                    proc.stdin.write(frame_data)
121	                    #TODO: skip flush for increased speed
122	                    frame_data = yield
123	                proc.stdin.flush()
124	                proc.stdin.close()
125	                res = proc.stderr.read()
126	            except BrokenPipeError as e:
127	                err = proc.stderr.read()
128	                #Check if output file exists. If it does, the re-execution
129	                #will also fail. This obscures the cause of the error
130	                #and seems to never occur concurrent to the metadata issue
131	                if os.path.exists(file_path):
132	                    raise Exception(&quot;An error occured in the ffmpeg subprocess:\n&quot; \
133	                            + err.decode(&quot;utf-8&quot;))
134	                #Res was not set
135	                print(err.decode(&quot;utf-8&quot;), end=&quot;&quot;, file=sys.stderr)
136	                logger.warn(&quot;An error occurred when saving with metadata&quot;)
137	    if res != b&#x27;&#x27;:
138	        with subprocess.Popen(args + [file_path], stderr=subprocess.PIPE,
139	                              stdin=subprocess.PIPE, env=env) as proc:
140	            try:
141	                while frame_data is not None:
142	                    proc.stdin.write(frame_data)
143	                    frame_data = yield
144	                proc.stdin.flush()
145	                proc.stdin.close()
146	                res = proc.stderr.read()
147	            except BrokenPipeError as e:
148	                res = proc.stderr.read()
149	                raise Exception(&quot;An error occured in the ffmpeg subprocess:\n&quot; \
150	                        + res.decode(&quot;utf-8&quot;))
151	    if len(res) &gt; 0:
152	        print(res.decode(&quot;utf-8&quot;), end=&quot;&quot;, file=sys.stderr)
153	
154	def to_pingpong(inp):
155	    if not hasattr(inp, &quot;__getitem__&quot;):
156	        inp = list(inp)
157	    yield from inp
158	    for i in range(len(inp)-2,0,-1):
159	        yield inp[i]
160	
161	class VideoCombine:
162	    @classmethod
163	    def INPUT_TYPES(s):
164	        ffmpeg_formats = get_video_formats()
165	        return {
166	            &quot;required&quot;: {
167	                &quot;images&quot;: (&quot;IMAGE&quot;,),
168	                &quot;frame_rate&quot;: (
169	                    &quot;FLOAT&quot;,
170	                    {&quot;default&quot;: 8, &quot;min&quot;: 1, &quot;step&quot;: 1},
171	                ),
172	                &quot;loop_count&quot;: (&quot;INT&quot;, {&quot;default&quot;: 0, &quot;min&quot;: 0, &quot;max&quot;: 100, &quot;step&quot;: 1}),
173	                &quot;filename_prefix&quot;: (&quot;STRING&quot;, {&quot;default&quot;: &quot;AnimateDiff&quot;}),
174	                &quot;format&quot;: ([&quot;image/gif&quot;, &quot;image/webp&quot;] + ffmpeg_formats,),
175	                &quot;pingpong&quot;: (&quot;BOOLEAN&quot;, {&quot;default&quot;: False}),
176	                &quot;save_output&quot;: (&quot;BOOLEAN&quot;, {&quot;default&quot;: True}),
</pre>
</div>


</div>
</div>

<div id="issue-2">
<div class="issue-block issue-sev-low">
    <b>subprocess_without_shell_equals_true: </b> subprocess call - check for execution of untrusted input.<br>
    <b>Test ID:</b> B603<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py</a><br>
    <b>Line number: </b>138<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html</a><br>

<div class="code">
<pre>
78	
79	def apply_format_widgets(format_name, kwargs):
80	    video_format_path = folder_paths.get_full_path(&quot;VHS_video_formats&quot;, format_name + &quot;.json&quot;)
81	    with open(video_format_path, &#x27;r&#x27;) as stream:
82	        video_format = json.load(stream)
83	    for w in gen_format_widgets(video_format):
84	        assert(w[0][0] in kwargs)
85	        w[0] = str(kwargs[w[0][0]])
86	    return video_format
87	
88	def tensor_to_int(tensor, bits):
89	    #TODO: investigate benefit of rounding by adding 0.5 before clip/cast
90	    tensor = tensor.cpu().numpy() * (2**bits-1)
91	    return np.clip(tensor, 0, (2**bits-1))
92	def tensor_to_shorts(tensor):
93	    return tensor_to_int(tensor, 16).astype(np.uint16)
94	def tensor_to_bytes(tensor):
95	    return tensor_to_int(tensor, 8).astype(np.uint8)
96	
97	def ffmpeg_process(args, video_format, video_metadata, file_path, env):
98	
99	    res = None
100	    frame_data = yield
101	    if video_format.get(&#x27;save_metadata&#x27;, &#x27;False&#x27;) != &#x27;False&#x27;:
102	        os.makedirs(folder_paths.get_temp_directory(), exist_ok=True)
103	        metadata = json.dumps(video_metadata)
104	        metadata_path = os.path.join(folder_paths.get_temp_directory(), &quot;metadata.txt&quot;)
105	        #metadata from file should  escape = ; # \ and newline
106	        metadata = metadata.replace(&quot;\\&quot;,&quot;\\\\&quot;)
107	        metadata = metadata.replace(&quot;;&quot;,&quot;\\;&quot;)
108	        metadata = metadata.replace(&quot;#&quot;,&quot;\\#&quot;)
109	        metadata = metadata.replace(&quot;=&quot;,&quot;\\=&quot;)
110	        metadata = metadata.replace(&quot;\n&quot;,&quot;\\\n&quot;)
111	        metadata = &quot;comment=&quot; + metadata
112	        with open(metadata_path, &quot;w&quot;) as f:
113	            f.write(&quot;;FFMETADATA1\n&quot;)
114	            f.write(metadata)
115	        m_args = args[:1] + [&quot;-i&quot;, metadata_path] + args[1:] + [&quot;-metadata&quot;, &quot;creation_time=now&quot;]
116	        with subprocess.Popen(m_args + [file_path], stderr=subprocess.PIPE,
117	                              stdin=subprocess.PIPE, env=env) as proc:
118	            try:
119	                while frame_data is not None:
120	                    proc.stdin.write(frame_data)
121	                    #TODO: skip flush for increased speed
122	                    frame_data = yield
123	                proc.stdin.flush()
124	                proc.stdin.close()
125	                res = proc.stderr.read()
126	            except BrokenPipeError as e:
127	                err = proc.stderr.read()
128	                #Check if output file exists. If it does, the re-execution
129	                #will also fail. This obscures the cause of the error
130	                #and seems to never occur concurrent to the metadata issue
131	                if os.path.exists(file_path):
132	                    raise Exception(&quot;An error occured in the ffmpeg subprocess:\n&quot; \
133	                            + err.decode(&quot;utf-8&quot;))
134	                #Res was not set
135	                print(err.decode(&quot;utf-8&quot;), end=&quot;&quot;, file=sys.stderr)
136	                logger.warn(&quot;An error occurred when saving with metadata&quot;)
137	    if res != b&#x27;&#x27;:
138	        with subprocess.Popen(args + [file_path], stderr=subprocess.PIPE,
139	                              stdin=subprocess.PIPE, env=env) as proc:
140	            try:
141	                while frame_data is not None:
142	                    proc.stdin.write(frame_data)
143	                    frame_data = yield
144	                proc.stdin.flush()
145	                proc.stdin.close()
146	                res = proc.stderr.read()
147	            except BrokenPipeError as e:
148	                res = proc.stderr.read()
149	                raise Exception(&quot;An error occured in the ffmpeg subprocess:\n&quot; \
150	                        + res.decode(&quot;utf-8&quot;))
151	    if len(res) &gt; 0:
152	        print(res.decode(&quot;utf-8&quot;), end=&quot;&quot;, file=sys.stderr)
153	
154	def to_pingpong(inp):
155	    if not hasattr(inp, &quot;__getitem__&quot;):
156	        inp = list(inp)
157	    yield from inp
158	    for i in range(len(inp)-2,0,-1):
159	        yield inp[i]
160	
161	class VideoCombine:
162	    @classmethod
163	    def INPUT_TYPES(s):
164	        ffmpeg_formats = get_video_formats()
165	        return {
166	            &quot;required&quot;: {
167	                &quot;images&quot;: (&quot;IMAGE&quot;,),
168	                &quot;frame_rate&quot;: (
169	                    &quot;FLOAT&quot;,
170	                    {&quot;default&quot;: 8, &quot;min&quot;: 1, &quot;step&quot;: 1},
171	                ),
172	                &quot;loop_count&quot;: (&quot;INT&quot;, {&quot;default&quot;: 0, &quot;min&quot;: 0, &quot;max&quot;: 100, &quot;step&quot;: 1}),
173	                &quot;filename_prefix&quot;: (&quot;STRING&quot;, {&quot;default&quot;: &quot;AnimateDiff&quot;}),
174	                &quot;format&quot;: ([&quot;image/gif&quot;, &quot;image/webp&quot;] + ffmpeg_formats,),
175	                &quot;pingpong&quot;: (&quot;BOOLEAN&quot;, {&quot;default&quot;: False}),
176	                &quot;save_output&quot;: (&quot;BOOLEAN&quot;, {&quot;default&quot;: True}),
177	            },
178	            &quot;optional&quot;: {
179	                &quot;audio&quot;: (&quot;VHS_AUDIO&quot;,),
180	                &quot;meta_batch&quot;: (&quot;VHS_BatchManager&quot;,)
181	            },
182	            &quot;hidden&quot;: {
183	                &quot;prompt&quot;: &quot;PROMPT&quot;,
184	                &quot;extra_pnginfo&quot;: &quot;EXTRA_PNGINFO&quot;,
185	                &quot;unique_id&quot;: &quot;UNIQUE_ID&quot;
186	            },
187	        }
188	
189	    RETURN_TYPES = (&quot;VHS_FILENAMES&quot;,)
190	    RETURN_NAMES = (&quot;Filenames&quot;,)
191	    OUTPUT_NODE = True
192	    CATEGORY = &quot;Video Helper Suite ðŸŽ¥ðŸ…¥ðŸ…—ðŸ…¢&quot;
193	    FUNCTION = &quot;combine_video&quot;
194	
195	    def combine_video(
196	        self,
197	        images,
198	        frame_rate: int,
</pre>
</div>


</div>
</div>

<div id="issue-3">
<div class="issue-block issue-sev-low">
    <b>subprocess_without_shell_equals_true: </b> subprocess call - check for execution of untrusted input.<br>
    <b>Test ID:</b> B603<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py</a><br>
    <b>Line number: </b>396<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html</a><br>

<div class="code">
<pre>
336	            if video_format.get(&#x27;input_color_depth&#x27;, &#x27;8bit&#x27;) == &#x27;16bit&#x27;:
337	                images = map(tensor_to_shorts, images)
338	                if has_alpha:
339	                    i_pix_fmt = &#x27;rgba64&#x27;
340	                else:
341	                    i_pix_fmt = &#x27;rgb48&#x27;
342	            else:
343	                images = map(tensor_to_bytes, images)
344	                if has_alpha:
345	                    i_pix_fmt = &#x27;rgba&#x27;
346	                else:
347	                    i_pix_fmt = &#x27;rgb24&#x27;
348	            file = f&quot;{filename}_{counter:05}.{video_format[&#x27;extension&#x27;]}&quot;
349	            file_path = os.path.join(full_output_folder, file)
350	            bitrate_arg = []
351	            bitrate = video_format.get(&#x27;bitrate&#x27;)
352	            if bitrate is not None:
353	                bitrate_arg = [&quot;-b:v&quot;, str(bitrate) + &quot;M&quot; if video_format.get(&#x27;megabit&#x27;) == &#x27;True&#x27; else str(bitrate) + &quot;K&quot;]
354	            args = [ffmpeg_path, &quot;-v&quot;, &quot;error&quot;, &quot;-f&quot;, &quot;rawvideo&quot;, &quot;-pix_fmt&quot;, i_pix_fmt,
355	                    &quot;-s&quot;, dimensions, &quot;-r&quot;, str(frame_rate), &quot;-i&quot;, &quot;-&quot;] \
356	                    + loop_args + video_format[&#x27;main_pass&#x27;] + bitrate_arg
357	
358	            env=os.environ.copy()
359	            if  &quot;environment&quot; in video_format:
360	                env.update(video_format[&quot;environment&quot;])
361	
362	            if output_process is None:
363	                output_process = ffmpeg_process(args, video_format, video_metadata, file_path, env)
364	                #Proceed to first yield
365	                output_process.send(None)
366	                if meta_batch is not None:
367	                    meta_batch.outputs[unique_id] = (counter, output_process)
368	
369	            for image in images:
370	                output_process.send(image.tobytes())
371	            if meta_batch is not None:
372	                requeue_workflow((meta_batch.unique_id, not meta_batch.has_closed_inputs))
373	            if meta_batch is None or meta_batch.has_closed_inputs:
374	                #Close pipe and wait for termination.
375	                try:
376	                    output_process.send(None)
377	                except StopIteration:
378	                    pass
379	                if meta_batch is not None:
380	                    meta_batch.outputs.pop(unique_id)
381	                    if len(meta_batch.outputs) == 0:
382	                        meta_batch.reset()
383	            else:
384	                #batch is unfinished
385	                #TODO: Check if empty output breaks other custom nodes
386	                return {&quot;ui&quot;: {&quot;unfinished_batch&quot;: [True]}, &quot;result&quot;: ((save_output, []),)}
387	
388	            output_files.append(file_path)
389	
390	            if &quot;gifski_pass&quot; in video_format:
391	                gif_output = f&quot;{filename}_{counter:05}.gif&quot;
392	                gif_output_path = os.path.join( full_output_folder, gif_output)
393	                gifski_args = [gifski_path] + video_format[&quot;gifski_pass&quot;] \
394	                        + [&quot;-o&quot;, gif_output_path, file_path]
395	                try:
396	                    res = subprocess.run(gifski_args, env=env, check=True, capture_output=True)
397	                except subprocess.CalledProcessError as e:
398	                    raise Exception(&quot;An error occured in the gifski subprocess:\n&quot; \
399	                            + e.stderr.decode(&quot;utf-8&quot;))
400	                if res.stderr:
401	                    print(res.stderr.decode(&quot;utf-8&quot;), end=&quot;&quot;, file=sys.stderr)
402	                #output format is actually an image and should be correctly marked
403	                #TODO: Evaluate a more consistent solution for this
404	                format = &quot;image/gif&quot;
405	                output_files.append(gif_output_path)
406	                file = gif_output
407	
408	            elif audio is not None and audio() is not False:
409	                # Create audio file if input was provided
410	                output_file_with_audio = f&quot;{filename}_{counter:05}-audio.{video_format[&#x27;extension&#x27;]}&quot;
411	                output_file_with_audio_path = os.path.join(full_output_folder, output_file_with_audio)
412	                if &quot;audio_pass&quot; not in video_format:
413	                    logger.warn(&quot;Selected video format does not have explicit audio support&quot;)
414	                    video_format[&quot;audio_pass&quot;] = [&quot;-c:a&quot;, &quot;libopus&quot;]
415	
416	
417	                # FFmpeg command with audio re-encoding
418	                #TODO: expose audio quality options if format widgets makes it in
419	                #Reconsider forcing apad/shortest
420	                mux_args = [ffmpeg_path, &quot;-v&quot;, &quot;error&quot;, &quot;-n&quot;, &quot;-i&quot;, file_path,
421	                            &quot;-i&quot;, &quot;-&quot;, &quot;-c:v&quot;, &quot;copy&quot;] \
422	                            + video_format[&quot;audio_pass&quot;] \
423	                            + [&quot;-af&quot;, &quot;apad&quot;, &quot;-shortest&quot;, output_file_with_audio_path]
424	
425	                try:
426	                    res = subprocess.run(mux_args, input=audio(), env=env,
427	                                         capture_output=True, check=True)
428	                except subprocess.CalledProcessError as e:
429	                    raise Exception(&quot;An error occured in the ffmpeg subprocess:\n&quot; \
430	                            + e.stderr.decode(&quot;utf-8&quot;))
431	                if res.stderr:
432	                    print(res.stderr.decode(&quot;utf-8&quot;), end=&quot;&quot;, file=sys.stderr)
433	                output_files.append(output_file_with_audio_path)
434	                #Return this file with audio to the webui.
435	                #It will be muted unless opened or saved with right click
436	                file = output_file_with_audio
437	
438	        previews = [
439	            {
440	                &quot;filename&quot;: file,
441	                &quot;subfolder&quot;: subfolder,
442	                &quot;type&quot;: &quot;output&quot; if save_output else &quot;temp&quot;,
443	                &quot;format&quot;: format,
444	            }
445	        ]
446	        return {&quot;ui&quot;: {&quot;gifs&quot;: previews}, &quot;result&quot;: ((save_output, output_files),)}
447	    @classmethod
448	    def VALIDATE_INPUTS(self, format, **kwargs):
449	        return True
450	
451	class LoadAudio:
452	    @classmethod
453	    def INPUT_TYPES(s):
454	        #Hide ffmpeg formats if ffmpeg isn&#x27;t available
455	        return {
</pre>
</div>


</div>
</div>

<div id="issue-4">
<div class="issue-block issue-sev-low">
    <b>subprocess_without_shell_equals_true: </b> subprocess call - check for execution of untrusted input.<br>
    <b>Test ID:</b> B603<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/nodes.py</a><br>
    <b>Line number: </b>426<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html</a><br>

<div class="code">
<pre>
366	                if meta_batch is not None:
367	                    meta_batch.outputs[unique_id] = (counter, output_process)
368	
369	            for image in images:
370	                output_process.send(image.tobytes())
371	            if meta_batch is not None:
372	                requeue_workflow((meta_batch.unique_id, not meta_batch.has_closed_inputs))
373	            if meta_batch is None or meta_batch.has_closed_inputs:
374	                #Close pipe and wait for termination.
375	                try:
376	                    output_process.send(None)
377	                except StopIteration:
378	                    pass
379	                if meta_batch is not None:
380	                    meta_batch.outputs.pop(unique_id)
381	                    if len(meta_batch.outputs) == 0:
382	                        meta_batch.reset()
383	            else:
384	                #batch is unfinished
385	                #TODO: Check if empty output breaks other custom nodes
386	                return {&quot;ui&quot;: {&quot;unfinished_batch&quot;: [True]}, &quot;result&quot;: ((save_output, []),)}
387	
388	            output_files.append(file_path)
389	
390	            if &quot;gifski_pass&quot; in video_format:
391	                gif_output = f&quot;{filename}_{counter:05}.gif&quot;
392	                gif_output_path = os.path.join( full_output_folder, gif_output)
393	                gifski_args = [gifski_path] + video_format[&quot;gifski_pass&quot;] \
394	                        + [&quot;-o&quot;, gif_output_path, file_path]
395	                try:
396	                    res = subprocess.run(gifski_args, env=env, check=True, capture_output=True)
397	                except subprocess.CalledProcessError as e:
398	                    raise Exception(&quot;An error occured in the gifski subprocess:\n&quot; \
399	                            + e.stderr.decode(&quot;utf-8&quot;))
400	                if res.stderr:
401	                    print(res.stderr.decode(&quot;utf-8&quot;), end=&quot;&quot;, file=sys.stderr)
402	                #output format is actually an image and should be correctly marked
403	                #TODO: Evaluate a more consistent solution for this
404	                format = &quot;image/gif&quot;
405	                output_files.append(gif_output_path)
406	                file = gif_output
407	
408	            elif audio is not None and audio() is not False:
409	                # Create audio file if input was provided
410	                output_file_with_audio = f&quot;{filename}_{counter:05}-audio.{video_format[&#x27;extension&#x27;]}&quot;
411	                output_file_with_audio_path = os.path.join(full_output_folder, output_file_with_audio)
412	                if &quot;audio_pass&quot; not in video_format:
413	                    logger.warn(&quot;Selected video format does not have explicit audio support&quot;)
414	                    video_format[&quot;audio_pass&quot;] = [&quot;-c:a&quot;, &quot;libopus&quot;]
415	
416	
417	                # FFmpeg command with audio re-encoding
418	                #TODO: expose audio quality options if format widgets makes it in
419	                #Reconsider forcing apad/shortest
420	                mux_args = [ffmpeg_path, &quot;-v&quot;, &quot;error&quot;, &quot;-n&quot;, &quot;-i&quot;, file_path,
421	                            &quot;-i&quot;, &quot;-&quot;, &quot;-c:v&quot;, &quot;copy&quot;] \
422	                            + video_format[&quot;audio_pass&quot;] \
423	                            + [&quot;-af&quot;, &quot;apad&quot;, &quot;-shortest&quot;, output_file_with_audio_path]
424	
425	                try:
426	                    res = subprocess.run(mux_args, input=audio(), env=env,
427	                                         capture_output=True, check=True)
428	                except subprocess.CalledProcessError as e:
429	                    raise Exception(&quot;An error occured in the ffmpeg subprocess:\n&quot; \
430	                            + e.stderr.decode(&quot;utf-8&quot;))
431	                if res.stderr:
432	                    print(res.stderr.decode(&quot;utf-8&quot;), end=&quot;&quot;, file=sys.stderr)
433	                output_files.append(output_file_with_audio_path)
434	                #Return this file with audio to the webui.
435	                #It will be muted unless opened or saved with right click
436	                file = output_file_with_audio
437	
438	        previews = [
439	            {
440	                &quot;filename&quot;: file,
441	                &quot;subfolder&quot;: subfolder,
442	                &quot;type&quot;: &quot;output&quot; if save_output else &quot;temp&quot;,
443	                &quot;format&quot;: format,
444	            }
445	        ]
446	        return {&quot;ui&quot;: {&quot;gifs&quot;: previews}, &quot;result&quot;: ((save_output, output_files),)}
447	    @classmethod
448	    def VALIDATE_INPUTS(self, format, **kwargs):
449	        return True
450	
451	class LoadAudio:
452	    @classmethod
453	    def INPUT_TYPES(s):
454	        #Hide ffmpeg formats if ffmpeg isn&#x27;t available
455	        return {
456	            &quot;required&quot;: {
457	                &quot;audio_file&quot;: (&quot;STRING&quot;, {&quot;default&quot;: &quot;input/&quot;, &quot;vhs_path_extensions&quot;: [&#x27;wav&#x27;,&#x27;mp3&#x27;,&#x27;ogg&#x27;,&#x27;m4a&#x27;,&#x27;flac&#x27;]}),
458	                },
459	            &quot;optional&quot; : {&quot;seek_seconds&quot;: (&quot;FLOAT&quot;, {&quot;default&quot;: 0, &quot;min&quot;: 0})}
460	        }
461	
462	    RETURN_TYPES = (&quot;VHS_AUDIO&quot;,)
463	    RETURN_NAMES = (&quot;audio&quot;,)
464	    CATEGORY = &quot;Video Helper Suite ðŸŽ¥ðŸ…¥ðŸ…—ðŸ…¢&quot;
465	    FUNCTION = &quot;load_audio&quot;
466	    def load_audio(self, audio_file, seek_seconds):
467	        if audio_file is None or validate_path(audio_file) != True:
468	            raise Exception(&quot;audio_file is not a valid path: &quot; + audio_file)
469	        #Eagerly fetch the audio since the user must be using it if the
470	        #node executes, unlike Load Video
471	        audio = get_audio(audio_file, start_time=seek_seconds)
472	        return (lambda : audio,)
473	
474	    @classmethod
475	    def IS_CHANGED(s, audio_file, seek_seconds):
476	        return hash_path(audio_file)
477	
478	    @classmethod
479	    def VALIDATE_INPUTS(s, audio_file, **kwargs):
480	        return validate_path(audio_file, allow_none=True)
481	
482	class LoadAudioUpload:
483	    @classmethod
484	    def INPUT_TYPES(s):
485	        input_dir = folder_paths.get_input_directory()
486	        files = []
</pre>
</div>


</div>
</div>

<div id="issue-5">
<div class="issue-block issue-sev-low">
    <b>blacklist: </b> Consider possible security implications associated with the subprocess module.<br>
    <b>Test ID:</b> B404<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/server.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/server.py</a><br>
    <b>Line number: </b>5<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/blacklists/blacklist_imports.html#b404-import-subprocess" target="_blank">https://bandit.readthedocs.io/en/1.7.9/blacklists/blacklist_imports.html#b404-import-subprocess</a><br>

<div class="code">
<pre>
1	import server
2	import folder_paths
3	import os
4	import time
5	import subprocess
6	from .utils import is_url, get_sorted_dir_files_from_directory, ffmpeg_path, validate_sequence
7	from comfy.k_diffusion.utils import FolderOfImages
8	
9	web = server.web
10	
11	def is_safe(path):
12	    if &quot;VHS_STRICT_PATHS&quot; not in os.environ:
13	        return True
14	    basedir = os.path.abspath(&#x27;.&#x27;)
15	    try:
16	        common_path = os.path.commonpath([basedir, path])
17	    except:
18	        #Different drive on windows
19	        return False
20	    return common_path == basedir
21	
22	@server.PromptServer.instance.routes.get(&quot;/viewvideo&quot;)
23	async def view_video(request):
24	    query = request.rel_url.query
25	    if &quot;filename&quot; not in query:
26	        return web.Response(status=404)
27	    filename = query[&quot;filename&quot;]
28	
29	    #Path code misformats urls on windows and must be skipped
30	    if is_url(filename):
31	        file = filename
32	    else:
33	        filename, output_dir = folder_paths.annotated_filepath(filename)
34	
35	        type = request.rel_url.query.get(&quot;type&quot;, &quot;output&quot;)
36	        if type == &quot;path&quot;:
37	            #special case for path_based nodes
38	            #NOTE: output_dir may be empty, but non-None
39	            output_dir, filename = os.path.split(filename)
40	        if output_dir is None:
41	            output_dir = folder_paths.get_directory_by_type(type)
42	
43	        if output_dir is None:
44	            return web.Response(status=400)
45	
46	        if not is_safe(output_dir):
47	            return web.Response(status=403)
48	
49	        if &quot;subfolder&quot; in request.rel_url.query:
50	            output_dir = os.path.join(output_dir, request.rel_url.query[&quot;subfolder&quot;])
51	
52	        filename = os.path.basename(filename)
53	        file = os.path.join(output_dir, filename)
54	
55	        if query.get(&#x27;format&#x27;, &#x27;video&#x27;) == &#x27;folder&#x27;:
56	            if not os.path.isdir(file):
57	                return web.Response(status=404)
58	        else:
59	            if not os.path.isfile(file) and not validate_sequence(file):
60	                    return web.Response(status=404)
61	
62	    if query.get(&#x27;format&#x27;, &#x27;video&#x27;) == &quot;folder&quot;:
63	        #Check that folder contains some valid image file, get it&#x27;s extension
64	        #ffmpeg seems to not support list globs, so support for mixed extensions seems unfeasible
65	        os.makedirs(folder_paths.get_temp_directory(), exist_ok=True)
66	        concat_file = os.path.join(folder_paths.get_temp_directory(), &quot;image_sequence_preview.txt&quot;)
67	        skip_first_images = int(query.get(&#x27;skip_first_images&#x27;, 0))
68	        select_every_nth = int(query.get(&#x27;select_every_nth&#x27;, 1))
69	        valid_images = get_sorted_dir_files_from_directory(file, skip_first_images, select_every_nth, FolderOfImages.IMG_EXTENSIONS)
70	        if len(valid_images) == 0:
71	            return web.Response(status=400)
72	        with open(concat_file, &quot;w&quot;) as f:
73	            f.write(&quot;ffconcat version 1.0\n&quot;)
74	            for path in valid_images:
75	                f.write(&quot;file &#x27;&quot; + os.path.abspath(path) + &quot;&#x27;\n&quot;)
76	                f.write(&quot;duration 0.125\n&quot;)
77	        in_args = [&quot;-safe&quot;, &quot;0&quot;, &quot;-i&quot;, concat_file]
78	    else:
79	        in_args = [&quot;-an&quot;, &quot;-i&quot;, file]
80	
81	    args = [ffmpeg_path, &quot;-v&quot;, &quot;error&quot;] + in_args
82	    vfilters = []
83	    if int(query.get(&#x27;force_rate&#x27;,0)) != 0:
84	        vfilters.append(&quot;fps=fps=&quot;+query[&#x27;force_rate&#x27;] + &quot;:round=up:start_time=0.001&quot;)
85	    if int(query.get(&#x27;skip_first_frames&#x27;, 0)) &gt; 0:
86	        vfilters.append(f&quot;select=gt(n\\,{int(query[&#x27;skip_first_frames&#x27;])-1})&quot;)
87	    if int(query.get(&#x27;select_every_nth&#x27;, 1)) &gt; 1:
88	        vfilters.append(f&quot;select=not(mod(n\\,{query[&#x27;select_every_nth&#x27;]}))&quot;)
89	    if query.get(&#x27;force_size&#x27;,&#x27;Disabled&#x27;) != &quot;Disabled&quot;:
90	        size = query[&#x27;force_size&#x27;].split(&#x27;x&#x27;)
91	        if size[0] == &#x27;?&#x27; or size[1] == &#x27;?&#x27;:
92	            size[0] = &quot;-2&quot; if size[0] == &#x27;?&#x27; else f&quot;&#x27;min({size[0]},iw)&#x27;&quot;
93	            size[1] = &quot;-2&quot; if size[1] == &#x27;?&#x27; else f&quot;&#x27;min({size[1]},ih)&#x27;&quot;
94	        else:
95	            #Aspect ratio is likely changed. A more complex command is required
96	            #to crop the output to the new aspect ratio
97	            ar = float(size[0])/float(size[1])
98	            vfilters.append(f&quot;crop=if(gt({ar}\\,a)\\,iw\\,ih*{ar}):if(gt({ar}\\,a)\\,iw/{ar}\\,ih)&quot;)
99	        size = &#x27;:&#x27;.join(size)
100	        vfilters.append(f&quot;scale={size}&quot;)
101	    vfilters.append(&quot;setpts=PTS-STARTPTS&quot;)
102	    if len(vfilters) &gt; 0:
103	        args += [&quot;-vf&quot;, &quot;,&quot;.join(vfilters)]
104	    if int(query.get(&#x27;frame_load_cap&#x27;, 0)) &gt; 0:
105	        args += [&quot;-frames:v&quot;, query[&#x27;frame_load_cap&#x27;]]
106	    #TODO:reconsider adding high frame cap/setting default frame cap on node
107	
108	    args += [&#x27;-c:v&#x27;, &#x27;libvpx-vp9&#x27;,&#x27;-deadline&#x27;, &#x27;realtime&#x27;, &#x27;-cpu-used&#x27;, &#x27;8&#x27;, &#x27;-f&#x27;, &#x27;webm&#x27;, &#x27;-&#x27;]
109	
110	    try:
111	        with subprocess.Popen(args, stdout=subprocess.PIPE) as proc:
112	            try:
113	                resp = web.StreamResponse()
114	                resp.content_type = &#x27;video/webm&#x27;
115	                resp.headers[&quot;Content-Disposition&quot;] = f&quot;filename=\&quot;{filename}\&quot;&quot;
116	                await resp.prepare(request)
117	                while True:
118	                    bytes_read = proc.stdout.read()
119	                    if bytes_read is None:
120	                        #TODO: check for timeout here
</pre>
</div>


</div>
</div>

<div id="issue-6">
<div class="issue-block issue-sev-low">
    <b>subprocess_without_shell_equals_true: </b> subprocess call - check for execution of untrusted input.<br>
    <b>Test ID:</b> B603<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/server.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/server.py</a><br>
    <b>Line number: </b>111<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html</a><br>

<div class="code">
<pre>
51	
52	        filename = os.path.basename(filename)
53	        file = os.path.join(output_dir, filename)
54	
55	        if query.get(&#x27;format&#x27;, &#x27;video&#x27;) == &#x27;folder&#x27;:
56	            if not os.path.isdir(file):
57	                return web.Response(status=404)
58	        else:
59	            if not os.path.isfile(file) and not validate_sequence(file):
60	                    return web.Response(status=404)
61	
62	    if query.get(&#x27;format&#x27;, &#x27;video&#x27;) == &quot;folder&quot;:
63	        #Check that folder contains some valid image file, get it&#x27;s extension
64	        #ffmpeg seems to not support list globs, so support for mixed extensions seems unfeasible
65	        os.makedirs(folder_paths.get_temp_directory(), exist_ok=True)
66	        concat_file = os.path.join(folder_paths.get_temp_directory(), &quot;image_sequence_preview.txt&quot;)
67	        skip_first_images = int(query.get(&#x27;skip_first_images&#x27;, 0))
68	        select_every_nth = int(query.get(&#x27;select_every_nth&#x27;, 1))
69	        valid_images = get_sorted_dir_files_from_directory(file, skip_first_images, select_every_nth, FolderOfImages.IMG_EXTENSIONS)
70	        if len(valid_images) == 0:
71	            return web.Response(status=400)
72	        with open(concat_file, &quot;w&quot;) as f:
73	            f.write(&quot;ffconcat version 1.0\n&quot;)
74	            for path in valid_images:
75	                f.write(&quot;file &#x27;&quot; + os.path.abspath(path) + &quot;&#x27;\n&quot;)
76	                f.write(&quot;duration 0.125\n&quot;)
77	        in_args = [&quot;-safe&quot;, &quot;0&quot;, &quot;-i&quot;, concat_file]
78	    else:
79	        in_args = [&quot;-an&quot;, &quot;-i&quot;, file]
80	
81	    args = [ffmpeg_path, &quot;-v&quot;, &quot;error&quot;] + in_args
82	    vfilters = []
83	    if int(query.get(&#x27;force_rate&#x27;,0)) != 0:
84	        vfilters.append(&quot;fps=fps=&quot;+query[&#x27;force_rate&#x27;] + &quot;:round=up:start_time=0.001&quot;)
85	    if int(query.get(&#x27;skip_first_frames&#x27;, 0)) &gt; 0:
86	        vfilters.append(f&quot;select=gt(n\\,{int(query[&#x27;skip_first_frames&#x27;])-1})&quot;)
87	    if int(query.get(&#x27;select_every_nth&#x27;, 1)) &gt; 1:
88	        vfilters.append(f&quot;select=not(mod(n\\,{query[&#x27;select_every_nth&#x27;]}))&quot;)
89	    if query.get(&#x27;force_size&#x27;,&#x27;Disabled&#x27;) != &quot;Disabled&quot;:
90	        size = query[&#x27;force_size&#x27;].split(&#x27;x&#x27;)
91	        if size[0] == &#x27;?&#x27; or size[1] == &#x27;?&#x27;:
92	            size[0] = &quot;-2&quot; if size[0] == &#x27;?&#x27; else f&quot;&#x27;min({size[0]},iw)&#x27;&quot;
93	            size[1] = &quot;-2&quot; if size[1] == &#x27;?&#x27; else f&quot;&#x27;min({size[1]},ih)&#x27;&quot;
94	        else:
95	            #Aspect ratio is likely changed. A more complex command is required
96	            #to crop the output to the new aspect ratio
97	            ar = float(size[0])/float(size[1])
98	            vfilters.append(f&quot;crop=if(gt({ar}\\,a)\\,iw\\,ih*{ar}):if(gt({ar}\\,a)\\,iw/{ar}\\,ih)&quot;)
99	        size = &#x27;:&#x27;.join(size)
100	        vfilters.append(f&quot;scale={size}&quot;)
101	    vfilters.append(&quot;setpts=PTS-STARTPTS&quot;)
102	    if len(vfilters) &gt; 0:
103	        args += [&quot;-vf&quot;, &quot;,&quot;.join(vfilters)]
104	    if int(query.get(&#x27;frame_load_cap&#x27;, 0)) &gt; 0:
105	        args += [&quot;-frames:v&quot;, query[&#x27;frame_load_cap&#x27;]]
106	    #TODO:reconsider adding high frame cap/setting default frame cap on node
107	
108	    args += [&#x27;-c:v&#x27;, &#x27;libvpx-vp9&#x27;,&#x27;-deadline&#x27;, &#x27;realtime&#x27;, &#x27;-cpu-used&#x27;, &#x27;8&#x27;, &#x27;-f&#x27;, &#x27;webm&#x27;, &#x27;-&#x27;]
109	
110	    try:
111	        with subprocess.Popen(args, stdout=subprocess.PIPE) as proc:
112	            try:
113	                resp = web.StreamResponse()
114	                resp.content_type = &#x27;video/webm&#x27;
115	                resp.headers[&quot;Content-Disposition&quot;] = f&quot;filename=\&quot;{filename}\&quot;&quot;
116	                await resp.prepare(request)
117	                while True:
118	                    bytes_read = proc.stdout.read()
119	                    if bytes_read is None:
120	                        #TODO: check for timeout here
121	                        time.sleep(.1)
122	                        continue
123	                    if len(bytes_read) == 0:
124	                        break
125	                    await resp.write(bytes_read)
126	            except ConnectionResetError as e:
127	                #Kill ffmpeg before stdout closes
128	                proc.kill()
129	    except BrokenPipeError as e:
130	        pass
131	    return resp
132	
133	@server.PromptServer.instance.routes.get(&quot;/getpath&quot;)
134	async def get_path(request):
135	    query = request.rel_url.query
136	    if &quot;path&quot; not in query:
137	        return web.Response(status=404)
138	    path = os.path.abspath(query[&quot;path&quot;])
139	
140	    if not os.path.exists(path) or not is_safe(path):
141	        return web.json_response([])
142	
143	    #Use get so None is default instead of keyerror
144	    valid_extensions = query.get(&quot;extensions&quot;)
145	    valid_items = []
146	    for item in os.scandir(path):
147	        try:
148	            if item.is_dir():
149	                valid_items.append(item.name + &quot;/&quot;)
150	                continue
151	            if valid_extensions is None or item.name.split(&quot;.&quot;)[-1] in valid_extensions:
152	                valid_items.append(item.name)
153	        except OSError:
154	            #Broken symlinks can throw a very unhelpful &quot;Invalid argument&quot;
155	            pass
156	
157	    return web.json_response(valid_items)
</pre>
</div>


</div>
</div>

<div id="issue-7">
<div class="issue-block issue-sev-low">
    <b>blacklist: </b> Consider possible security implications associated with the subprocess module.<br>
    <b>Test ID:</b> B404<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/utils.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/utils.py</a><br>
    <b>Line number: </b>5<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/blacklists/blacklist_imports.html#b404-import-subprocess" target="_blank">https://bandit.readthedocs.io/en/1.7.9/blacklists/blacklist_imports.html#b404-import-subprocess</a><br>

<div class="code">
<pre>
1	import hashlib
2	import os
3	from typing import Iterable
4	import shutil
5	import subprocess
6	import re
7	
8	import server
9	from .logger import logger
10	
11	BIGMIN = -(2**53-1)
12	BIGMAX = (2**53-1)
13	
14	DIMMAX = 8192
15	
16	def ffmpeg_suitability(path):
17	    try:
18	        version = subprocess.run([path, &quot;-version&quot;], check=True,
19	                                 capture_output=True).stdout.decode(&quot;utf-8&quot;)
20	    except:
21	        return 0
22	    score = 0
23	    #rough layout of the importance of various features
24	    simple_criterion = [(&quot;libvpx&quot;, 20),(&quot;264&quot;,10), (&quot;265&quot;,3),
25	                        (&quot;svtav1&quot;,5),(&quot;libopus&quot;, 1)]
26	    for criterion in simple_criterion:
27	        if version.find(criterion[0]) &gt;= 0:
28	            score += criterion[1]
29	    #obtain rough compile year from copyright information
30	    copyright_index = version.find(&#x27;2000-2&#x27;)
31	    if copyright_index &gt;= 0:
32	        copyright_year = version[copyright_index+6:copyright_index+9]
33	        if copyright_year.isnumeric():
34	            score += int(copyright_year)
35	    return score
36	
37	
38	if &quot;VHS_FORCE_FFMPEG_PATH&quot; in os.environ:
39	    ffmpeg_path = os.environ.get(&quot;VHS_FORCE_FFMPEG_PATH&quot;)
40	else:
41	    ffmpeg_paths = []
42	    try:
43	        from imageio_ffmpeg import get_ffmpeg_exe
44	        imageio_ffmpeg_path = get_ffmpeg_exe()
45	        ffmpeg_paths.append(imageio_ffmpeg_path)
46	    except:
47	        if &quot;VHS_USE_IMAGEIO_FFMPEG&quot; in os.environ:
48	            raise
49	        logger.warn(&quot;Failed to import imageio_ffmpeg&quot;)
50	    if &quot;VHS_USE_IMAGEIO_FFMPEG&quot; in os.environ:
51	        ffmpeg_path = imageio_ffmpeg_path
52	    else:
53	        system_ffmpeg = shutil.which(&quot;ffmpeg&quot;)
54	        if system_ffmpeg is not None:
55	            ffmpeg_paths.append(system_ffmpeg)
56	        if os.path.isfile(&quot;ffmpeg&quot;):
57	            ffmpeg_paths.append(os.path.abspath(&quot;ffmpeg&quot;))
58	        if os.path.isfile(&quot;ffmpeg.exe&quot;):
59	            ffmpeg_paths.append(os.path.abspath(&quot;ffmpeg.exe&quot;))
60	        if len(ffmpeg_paths) == 0:
61	            logger.error(&quot;No valid ffmpeg found.&quot;)
62	            ffmpeg_path = None
63	        elif len(ffmpeg_paths) == 1:
64	            #Evaluation of suitability isn&#x27;t required, can take sole option
65	            #to reduce startup time
66	            ffmpeg_path = ffmpeg_paths[0]
67	        else:
68	            ffmpeg_path = max(ffmpeg_paths, key=ffmpeg_suitability)
69	gifski_path = os.environ.get(&quot;VHS_GIFSKI&quot;, None)
70	if gifski_path is None:
71	    gifski_path = os.environ.get(&quot;JOV_GIFSKI&quot;, None)
72	    if gifski_path is None:
73	        gifski_path = shutil.which(&quot;gifski&quot;)
74	
75	def get_sorted_dir_files_from_directory(directory: str, skip_first_images: int=0, select_every_nth: int=1, extensions: Iterable=None):
76	    directory = directory.strip()
77	    dir_files = os.listdir(directory)
78	    dir_files = sorted(dir_files)
79	    dir_files = [os.path.join(directory, x) for x in dir_files]
80	    dir_files = list(filter(lambda filepath: os.path.isfile(filepath), dir_files))
81	    # filter by extension, if needed
82	    if extensions is not None:
83	        extensions = list(extensions)
84	        new_dir_files = []
85	        for filepath in dir_files:
86	            ext = &quot;.&quot; + filepath.split(&quot;.&quot;)[-1]
87	            if ext.lower() in extensions:
88	                new_dir_files.append(filepath)
89	        dir_files = new_dir_files
90	    # start at skip_first_images
91	    dir_files = dir_files[skip_first_images:]
92	    dir_files = dir_files[0::select_every_nth]
93	    return dir_files
94	
95	
96	# modified from https://stackoverflow.com/questions/22058048/hashing-a-file-in-python
97	def calculate_file_hash(filename: str, hash_every_n: int = 1):
98	    #Larger video files were taking &gt;.5 seconds to hash even when cached,
99	    #so instead the modified time from the filesystem is used as a hash
100	    h = hashlib.sha256()
101	    h.update(filename.encode())
102	    h.update(str(os.path.getmtime(filename)).encode())
103	    return h.hexdigest()
104	
105	prompt_queue = server.PromptServer.instance.prompt_queue
106	def requeue_workflow_unchecked():
107	    &quot;&quot;&quot;Requeues the current workflow without checking for multiple requeues&quot;&quot;&quot;
108	    currently_running = prompt_queue.currently_running
109	    (_, _, prompt, extra_data, outputs_to_execute) = next(iter(currently_running.values()))
110	
111	    #Ensure batch_managers are marked stale
112	    prompt = prompt.copy()
113	    for uid in prompt:
114	        if prompt[uid][&#x27;class_type&#x27;] == &#x27;VHS_BatchManager&#x27;:
115	            prompt[uid][&#x27;inputs&#x27;][&#x27;requeue&#x27;] = prompt[uid][&#x27;inputs&#x27;].get(&#x27;requeue&#x27;,0)+1
116	
117	    #execution.py has guards for concurrency, but server doesn&#x27;t.
118	    #TODO: Check that this won&#x27;t be an issue
119	    number = -server.PromptServer.instance.number
120	    server.PromptServer.instance.number += 1
</pre>
</div>


</div>
</div>

<div id="issue-8">
<div class="issue-block issue-sev-low">
    <b>subprocess_without_shell_equals_true: </b> subprocess call - check for execution of untrusted input.<br>
    <b>Test ID:</b> B603<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/utils.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/utils.py</a><br>
    <b>Line number: </b>18<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html</a><br>

<div class="code">
<pre>
1	import hashlib
2	import os
3	from typing import Iterable
4	import shutil
5	import subprocess
6	import re
7	
8	import server
9	from .logger import logger
10	
11	BIGMIN = -(2**53-1)
12	BIGMAX = (2**53-1)
13	
14	DIMMAX = 8192
15	
16	def ffmpeg_suitability(path):
17	    try:
18	        version = subprocess.run([path, &quot;-version&quot;], check=True,
19	                                 capture_output=True).stdout.decode(&quot;utf-8&quot;)
20	    except:
21	        return 0
22	    score = 0
23	    #rough layout of the importance of various features
24	    simple_criterion = [(&quot;libvpx&quot;, 20),(&quot;264&quot;,10), (&quot;265&quot;,3),
25	                        (&quot;svtav1&quot;,5),(&quot;libopus&quot;, 1)]
26	    for criterion in simple_criterion:
27	        if version.find(criterion[0]) &gt;= 0:
28	            score += criterion[1]
29	    #obtain rough compile year from copyright information
30	    copyright_index = version.find(&#x27;2000-2&#x27;)
31	    if copyright_index &gt;= 0:
32	        copyright_year = version[copyright_index+6:copyright_index+9]
33	        if copyright_year.isnumeric():
34	            score += int(copyright_year)
35	    return score
36	
37	
38	if &quot;VHS_FORCE_FFMPEG_PATH&quot; in os.environ:
39	    ffmpeg_path = os.environ.get(&quot;VHS_FORCE_FFMPEG_PATH&quot;)
40	else:
41	    ffmpeg_paths = []
42	    try:
43	        from imageio_ffmpeg import get_ffmpeg_exe
44	        imageio_ffmpeg_path = get_ffmpeg_exe()
45	        ffmpeg_paths.append(imageio_ffmpeg_path)
46	    except:
47	        if &quot;VHS_USE_IMAGEIO_FFMPEG&quot; in os.environ:
48	            raise
49	        logger.warn(&quot;Failed to import imageio_ffmpeg&quot;)
50	    if &quot;VHS_USE_IMAGEIO_FFMPEG&quot; in os.environ:
51	        ffmpeg_path = imageio_ffmpeg_path
52	    else:
53	        system_ffmpeg = shutil.which(&quot;ffmpeg&quot;)
54	        if system_ffmpeg is not None:
55	            ffmpeg_paths.append(system_ffmpeg)
56	        if os.path.isfile(&quot;ffmpeg&quot;):
57	            ffmpeg_paths.append(os.path.abspath(&quot;ffmpeg&quot;))
58	        if os.path.isfile(&quot;ffmpeg.exe&quot;):
59	            ffmpeg_paths.append(os.path.abspath(&quot;ffmpeg.exe&quot;))
60	        if len(ffmpeg_paths) == 0:
61	            logger.error(&quot;No valid ffmpeg found.&quot;)
62	            ffmpeg_path = None
63	        elif len(ffmpeg_paths) == 1:
64	            #Evaluation of suitability isn&#x27;t required, can take sole option
65	            #to reduce startup time
66	            ffmpeg_path = ffmpeg_paths[0]
67	        else:
68	            ffmpeg_path = max(ffmpeg_paths, key=ffmpeg_suitability)
69	gifski_path = os.environ.get(&quot;VHS_GIFSKI&quot;, None)
70	if gifski_path is None:
71	    gifski_path = os.environ.get(&quot;JOV_GIFSKI&quot;, None)
72	    if gifski_path is None:
73	        gifski_path = shutil.which(&quot;gifski&quot;)
74	
75	def get_sorted_dir_files_from_directory(directory: str, skip_first_images: int=0, select_every_nth: int=1, extensions: Iterable=None):
76	    directory = directory.strip()
77	    dir_files = os.listdir(directory)
78	    dir_files = sorted(dir_files)
79	    dir_files = [os.path.join(directory, x) for x in dir_files]
80	    dir_files = list(filter(lambda filepath: os.path.isfile(filepath), dir_files))
81	    # filter by extension, if needed
82	    if extensions is not None:
83	        extensions = list(extensions)
84	        new_dir_files = []
85	        for filepath in dir_files:
86	            ext = &quot;.&quot; + filepath.split(&quot;.&quot;)[-1]
87	            if ext.lower() in extensions:
88	                new_dir_files.append(filepath)
89	        dir_files = new_dir_files
90	    # start at skip_first_images
91	    dir_files = dir_files[skip_first_images:]
92	    dir_files = dir_files[0::select_every_nth]
93	    return dir_files
94	
95	
96	# modified from https://stackoverflow.com/questions/22058048/hashing-a-file-in-python
97	def calculate_file_hash(filename: str, hash_every_n: int = 1):
98	    #Larger video files were taking &gt;.5 seconds to hash even when cached,
99	    #so instead the modified time from the filesystem is used as a hash
100	    h = hashlib.sha256()
101	    h.update(filename.encode())
102	    h.update(str(os.path.getmtime(filename)).encode())
103	    return h.hexdigest()
104	
105	prompt_queue = server.PromptServer.instance.prompt_queue
106	def requeue_workflow_unchecked():
107	    &quot;&quot;&quot;Requeues the current workflow without checking for multiple requeues&quot;&quot;&quot;
108	    currently_running = prompt_queue.currently_running
109	    (_, _, prompt, extra_data, outputs_to_execute) = next(iter(currently_running.values()))
110	
111	    #Ensure batch_managers are marked stale
112	    prompt = prompt.copy()
113	    for uid in prompt:
114	        if prompt[uid][&#x27;class_type&#x27;] == &#x27;VHS_BatchManager&#x27;:
115	            prompt[uid][&#x27;inputs&#x27;][&#x27;requeue&#x27;] = prompt[uid][&#x27;inputs&#x27;].get(&#x27;requeue&#x27;,0)+1
116	
117	    #execution.py has guards for concurrency, but server doesn&#x27;t.
118	    #TODO: Check that this won&#x27;t be an issue
119	    number = -server.PromptServer.instance.number
120	    server.PromptServer.instance.number += 1
121	    prompt_id = str(server.uuid.uuid4())
</pre>
</div>


</div>
</div>

<div id="issue-9">
<div class="issue-block issue-sev-low">
    <b>subprocess_without_shell_equals_true: </b> subprocess call - check for execution of untrusted input.<br>
    <b>Test ID:</b> B603<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/78.html" target="_blank">CWE-78</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/utils.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-VideoHelperSuite/videohelpersuite/utils.py</a><br>
    <b>Line number: </b>152<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b603_subprocess_without_shell_equals_true.html</a><br>

<div class="code">
<pre>
92	    dir_files = dir_files[0::select_every_nth]
93	    return dir_files
94	
95	
96	# modified from https://stackoverflow.com/questions/22058048/hashing-a-file-in-python
97	def calculate_file_hash(filename: str, hash_every_n: int = 1):
98	    #Larger video files were taking &gt;.5 seconds to hash even when cached,
99	    #so instead the modified time from the filesystem is used as a hash
100	    h = hashlib.sha256()
101	    h.update(filename.encode())
102	    h.update(str(os.path.getmtime(filename)).encode())
103	    return h.hexdigest()
104	
105	prompt_queue = server.PromptServer.instance.prompt_queue
106	def requeue_workflow_unchecked():
107	    &quot;&quot;&quot;Requeues the current workflow without checking for multiple requeues&quot;&quot;&quot;
108	    currently_running = prompt_queue.currently_running
109	    (_, _, prompt, extra_data, outputs_to_execute) = next(iter(currently_running.values()))
110	
111	    #Ensure batch_managers are marked stale
112	    prompt = prompt.copy()
113	    for uid in prompt:
114	        if prompt[uid][&#x27;class_type&#x27;] == &#x27;VHS_BatchManager&#x27;:
115	            prompt[uid][&#x27;inputs&#x27;][&#x27;requeue&#x27;] = prompt[uid][&#x27;inputs&#x27;].get(&#x27;requeue&#x27;,0)+1
116	
117	    #execution.py has guards for concurrency, but server doesn&#x27;t.
118	    #TODO: Check that this won&#x27;t be an issue
119	    number = -server.PromptServer.instance.number
120	    server.PromptServer.instance.number += 1
121	    prompt_id = str(server.uuid.uuid4())
122	    prompt_queue.put((number, prompt_id, prompt, extra_data, outputs_to_execute))
123	
124	requeue_guard = [None, 0, 0, {}]
125	def requeue_workflow(requeue_required=(-1,True)):
126	    assert(len(prompt_queue.currently_running) == 1)
127	    global requeue_guard
128	    (run_number, _, prompt, _, _) = next(iter(prompt_queue.currently_running.values()))
129	    if requeue_guard[0] != run_number:
130	        #Calculate a count of how many outputs are managed by a batch manager
131	        managed_outputs=0
132	        for bm_uid in prompt:
133	            if prompt[bm_uid][&#x27;class_type&#x27;] == &#x27;VHS_BatchManager&#x27;:
134	                for output_uid in prompt:
135	                    if prompt[output_uid][&#x27;class_type&#x27;] in [&quot;VHS_VideoCombine&quot;]:
136	                        for inp in prompt[output_uid][&#x27;inputs&#x27;].values():
137	                            if inp == [bm_uid, 0]:
138	                                managed_outputs+=1
139	        requeue_guard = [run_number, 0, managed_outputs, {}]
140	    requeue_guard[1] = requeue_guard[1]+1
141	    requeue_guard[3][requeue_required[0]] = requeue_required[1]
142	    if requeue_guard[1] == requeue_guard[2] and max(requeue_guard[3].values()):
143	        requeue_workflow_unchecked()
144	
145	def get_audio(file, start_time=0, duration=0):
146	    args = [ffmpeg_path, &quot;-v&quot;, &quot;error&quot;, &quot;-i&quot;, file]
147	    if start_time &gt; 0:
148	        args += [&quot;-ss&quot;, str(start_time)]
149	    if duration &gt; 0:
150	        args += [&quot;-t&quot;, str(duration)]
151	    try:
152	        res =  subprocess.run(args + [&quot;-f&quot;, &quot;wav&quot;, &quot;-&quot;],
153	                              stdout=subprocess.PIPE, check=True).stdout
154	    except subprocess.CalledProcessError as e:
155	        logger.warning(f&quot;Failed to extract audio from: {file}&quot;)
156	        return False
157	    return res
158	
159	
160	def lazy_eval(func):
161	    class Cache:
162	        def __init__(self, func):
163	            self.res = None
164	            self.func = func
165	        def get(self):
166	            if self.res is None:
167	                self.res = self.func()
168	            return self.res
169	    cache = Cache(func)
170	    return lambda : cache.get()
171	
172	
173	def is_url(url):
174	    return url.split(&quot;://&quot;)[0] in [&quot;http&quot;, &quot;https&quot;]
175	
176	def validate_sequence(path):
177	    #Check if path is a valid ffmpeg sequence that points to at least one file
178	    (path, file) = os.path.split(path)
179	    if not os.path.isdir(path):
180	        return False
181	    match = re.search(&#x27;%0?\d+d&#x27;, file)
182	    if not match:
183	        return False
184	    seq = match.group()
185	    if seq == &#x27;%d&#x27;:
186	        seq = &#x27;\\\\d+&#x27;
187	    else:
188	        seq = &#x27;\\\\d{%s}&#x27; % seq[1:-1]
189	    file_matcher = re.compile(re.sub(&#x27;%0?\d+d&#x27;, seq, file))
190	    for file in os.listdir(path):
191	        if file_matcher.fullmatch(file):
192	            return True
193	    return False
194	
195	def hash_path(path):
196	    if path is None:
197	        return &quot;input&quot;
198	    if is_url(path):
199	        return &quot;url&quot;
200	    return calculate_file_hash(path.strip(&quot;\&quot;&quot;))
201	
202	
203	def validate_path(path, allow_none=False, allow_url=True):
204	    if path is None:
205	        return allow_none
206	    if is_url(path):
207	        #Probably not feasible to check if url resolves here
208	        return True if allow_url else &quot;URLs are unsupported for this path&quot;
209	    if not os.path.isfile(path.strip(&quot;\&quot;&quot;)):
210	        return &quot;Invalid file path: {}&quot;.format(path)
211	    return True
</pre>
</div>


</div>
</div>

</div>

</body>
</html>
