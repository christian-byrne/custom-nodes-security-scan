
<!DOCTYPE html>
<html>
<head>

<meta charset="UTF-8">

<title>
    Bandit Report
</title>

<style>

html * {
    font-family: "Arial", sans-serif;
}

pre {
    font-family: "Monaco", monospace;
}

.bordered-box {
    border: 1px solid black;
    padding-top:.5em;
    padding-bottom:.5em;
    padding-left:1em;
}

.metrics-box {
    font-size: 1.1em;
    line-height: 130%;
}

.metrics-title {
    font-size: 1.5em;
    font-weight: 500;
    margin-bottom: .25em;
}

.issue-description {
    font-size: 1.3em;
    font-weight: 500;
}

.candidate-issues {
    margin-left: 2em;
    border-left: solid 1px; LightGray;
    padding-left: 5%;
    margin-top: .2em;
    margin-bottom: .2em;
}

.issue-block {
    border: 1px solid LightGray;
    padding-left: .5em;
    padding-top: .5em;
    padding-bottom: .5em;
    margin-bottom: .5em;
}

.issue-sev-high {
    background-color: Pink;
}

.issue-sev-medium {
    background-color: NavajoWhite;
}

.issue-sev-low {
    background-color: LightCyan;
}

</style>
</head>

<body>

<div id="metrics">
    <div class="metrics-box bordered-box">
        <div class="metrics-title">
            Metrics:<br>
        </div>
        Total lines of code: <span id="loc">236</span><br>
        Total lines skipped (#nosec): <span id="nosec">0</span>
    </div>
</div>




<br>
<div id="results">
    
<div id="issue-0">
<div class="issue-block issue-sev-low">
    <b>try_except_pass: </b> Try, Except, Pass detected.<br>
    <b>Test ID:</b> B110<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/703.html" target="_blank">CWE-703</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-Image-Selector/__init__.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-Image-Selector/__init__.py</a><br>
    <b>Line number: </b>93<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b110_try_except_pass.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b110_try_except_pass.html</a><br>

<div class="code">
<pre>
33	        Indexes start with 1 for simplicity
34	        &quot;&quot;&quot;
35	        return {
36	            &quot;required&quot;: {
37	                &quot;images&quot;: (&quot;IMAGE&quot;, ),
38	                &quot;selected_indexes&quot;: (&quot;STRING&quot;, {
39	                    &quot;multiline&quot;: False,
40	                    &quot;default&quot;: &quot;1,2,3&quot;
41	                }),
42	            },
43	        }
44	
45	    RETURN_TYPES = (&quot;IMAGE&quot;, )
46	    # RETURN_NAMES = (&quot;image_output_name&quot;,)
47	
48	    FUNCTION = &quot;run&quot;
49	
50	    OUTPUT_NODE = False
51	
52	    CATEGORY = &quot;image&quot;
53	
54	    def run(self, images: torch.Tensor, selected_indexes: str):
55	        &quot;&quot;&quot;
56	        根据 selected_indexes 选择 images 中的图片，支持连续索引和范围索引
57	
58	        Args:
59	            images (torch.Tensor): 输入的图像张量，维度为 [N, C, H, W], 其中 N 为图片数量, C 为通道数, H、W 为图片的高和宽。
60	            selected_indexes (str): 选择的图片索引，支持连续索引和范围索引，例如：&quot;0,2,4:6,8&quot; 表示选择第1、3、5张和第2、4、6、8张图片。
61	
62	        Returns:
63	            tuple: 选择的图片张量，维度为 [N&#x27;, C, H, W]，其中 N&#x27; 为选择的图片数量。
64	
65	        &quot;&quot;&quot;
66	        shape = images.shape
67	        len_first_dim = shape[0]
68	
69	        selected_index: list[int] = []
70	        total_indexes: list[int] = list(range(len_first_dim))
71	        for s in selected_indexes.strip().split(&#x27;,&#x27;):
72	            try:
73	                if &quot;:&quot; in s:
74	                    _li = s.strip().split(&#x27;:&#x27;, maxsplit=1)
75	                    _start = _li[0]
76	                    _end = _li[1]
77	                    if _start and _end:
78	                        selected_index.extend(
79	                            total_indexes[int(_start) - 1:int(_end) - 1]
80	                        )
81	                    elif _start:
82	                        selected_index.extend(
83	                            total_indexes[int(_start) - 1:]
84	                        )
85	                    elif _end:
86	                        selected_index.extend(
87	                            total_indexes[:int(_end) - 1]
88	                        )
89	                else:
90	                    x: int = int(s.strip()) - 1
91	                    if x &lt; len_first_dim:
92	                        selected_index.append(x)
93	            except:
94	                pass
95	
96	        if selected_index:
97	            print(f&quot;ImageSelector: selected: {len(selected_index)} images&quot;)
98	            return (images[selected_index], )
99	
100	        print(f&quot;ImageSelector: selected no images, passthrough&quot;)
101	        return (images, )
102	
103	
104	class ImageDuplicator:
105	    &quot;&quot;&quot;
106	    Duplicate each images and pipe through
107	    &quot;&quot;&quot;
108	
109	    def __init__(self):
110	        self._name = &quot;ImageDuplicator&quot;
111	        pass
112	
113	    @classmethod
114	    def INPUT_TYPES(s):
115	        &quot;&quot;&quot;
116	        Input: copies you want to get
117	        &quot;&quot;&quot;
118	        return {
119	            &quot;required&quot;: {
120	                &quot;images&quot;: (&quot;IMAGE&quot;, ),
121	                &quot;dup_times&quot;: (&quot;INT&quot;, {
122	                    &quot;default&quot;: 2,
123	                    &quot;min&quot;: 1,
124	                    &quot;max&quot;: 16,
125	                    &quot;step&quot;: 1,
126	                }),
127	            },
128	        }
129	
130	    RETURN_TYPES = (&quot;IMAGE&quot;, )
131	    # RETURN_NAMES = (&quot;image_output_name&quot;,)
132	
133	    FUNCTION = &quot;run&quot;
134	
135	    OUTPUT_NODE = False
136	
137	    CATEGORY = &quot;image&quot;
138	
139	    def run(self, images: torch.Tensor, dup_times: int):
140	        &quot;&quot;&quot;
141	        对输入的图像张量进行复制多次，并将复制后的张量拼接起来返回。
142	
143	        Args:
144	            images (torch.Tensor): 输入的图像张量，维度为 (batch_size, channels, height, width)。
145	            dup_times (int): 复制的次数。
146	
147	        Returns:
148	            torch.Tensor: 拼接后的图像张量，维度为 (batch_size * dup_times, channels, height, width)。
149	
150	        &quot;&quot;&quot;
151	
152	        tensor_list = [images
153	                       ] + [torch.clone(images) for _ in range(dup_times - 1)]
</pre>
</div>


</div>
</div>

<div id="issue-1">
<div class="issue-block issue-sev-low">
    <b>try_except_pass: </b> Try, Except, Pass detected.<br>
    <b>Test ID:</b> B110<br>
    <b>Severity: </b>LOW<br>
    <b>Confidence: </b>HIGH<br>
    <b>CWE: </b><a href="https://cwe.mitre.org/data/definitions/703.html" target="_blank">CWE-703</a><br>
    <b>File: </b><a href="/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-Image-Selector/__init__.py" target="_blank">/home/c_byrne/tools/sd/sd-interfaces/ComfyUI/custom_nodes/ComfyUI-Image-Selector/__init__.py</a><br>
    <b>Line number: </b>235<br>
    <b>More info: </b><a href="https://bandit.readthedocs.io/en/1.7.9/plugins/b110_try_except_pass.html" target="_blank">https://bandit.readthedocs.io/en/1.7.9/plugins/b110_try_except_pass.html</a><br>

<div class="code">
<pre>
175	        Indexes start with 1 for simplicity
176	        &quot;&quot;&quot;
177	        return {
178	            &quot;required&quot;: {
179	                &quot;latent_image&quot;: (&quot;LATENT&quot;, ),
180	                &quot;selected_indexes&quot;: (&quot;STRING&quot;, {
181	                    &quot;multiline&quot;: False,
182	                    &quot;default&quot;: &quot;1,2,3&quot;
183	                }),
184	            },
185	        }
186	
187	    RETURN_TYPES = (&quot;LATENT&quot;, )
188	    # RETURN_NAMES = (&quot;image_output_name&quot;,)
189	
190	    FUNCTION = &quot;run&quot;
191	
192	    OUTPUT_NODE = False
193	
194	    CATEGORY = &quot;latent&quot;
195	
196	    def run(self, latent_image: clabc.Mapping[str, torch.Tensor],
197	            selected_indexes: str):
198	        &quot;&quot;&quot;
199	        对latent_image进行筛选，根据selected_indexes指定的索引进行筛选
200	        Args:
201	            latent_image: 待筛选的latent_image，Mapping[str, torch.Tensor]，包含&#x27;samples&#x27;字段
202	            selected_indexes: 待筛选的索引，以逗号分隔，支持连续索引范围以冒号分隔，例如&#x27;1,3,5:7,9&#x27;
203	
204	        Returns:
205	            筛选后的latent_image，Mapping[str, torch.Tensor]
206	        &quot;&quot;&quot;
207	        samples = latent_image[&#x27;samples&#x27;]
208	        shape = samples.shape
209	        len_first_dim = shape[0]
210	
211	        selected_index: list[int] = []
212	        total_indexes: list[int] = list(range(len_first_dim))
213	        for s in selected_indexes.strip().split(&#x27;,&#x27;):
214	            try:
215	                if &quot;:&quot; in s:
216	                    _li = s.strip().split(&#x27;:&#x27;, maxsplit=1)
217	                    _start = _li[0]
218	                    _end = _li[1]
219	                    if _start and _end:
220	                        selected_index.extend(
221	                            total_indexes[int(_start) - 1:int(_end) - 1]
222	                        )
223	                    elif _start:
224	                        selected_index.extend(
225	                            total_indexes[int(_start) - 1:]
226	                        )
227	                    elif _end:
228	                        selected_index.extend(
229	                            total_indexes[:int(_end) - 1]
230	                        )
231	                else:
232	                    x: int = int(s.strip()) - 1
233	                    if x &lt; len_first_dim:
234	                        selected_index.append(x)
235	            except:
236	                pass
237	
238	        if selected_index:
239	            print(f&quot;LatentSelector: selected: {len(selected_index)} latents&quot;)
240	            return ({&#x27;samples&#x27;: samples[selected_index, :, :, :]}, )
241	
242	        print(f&quot;LatentSelector: selected no latents, passthrough&quot;)
243	        return (latent_image, )
244	
245	
246	class LatentDuplicator:
247	    &quot;&quot;&quot;
248	    Duplicate each latent images and pipe through
249	    &quot;&quot;&quot;
250	
251	    def __init__(self):
252	        pass
253	
254	    @classmethod
255	    def INPUT_TYPES(s):
256	        &quot;&quot;&quot;
257	        Input: copies you want to get
258	        &quot;&quot;&quot;
259	        return {
260	            &quot;required&quot;: {
261	                &quot;latent_image&quot;: (&quot;LATENT&quot;, ),
262	                &quot;dup_times&quot;: (&quot;INT&quot;, {
263	                    &quot;default&quot;: 2,
264	                    &quot;min&quot;: 1,
265	                    &quot;max&quot;: 16,
266	                    &quot;step&quot;: 1,
267	                }),
268	            },
269	        }
270	
271	    RETURN_TYPES = (&quot;LATENT&quot;, )
272	    # RETURN_NAMES = (&quot;image_output_name&quot;,)
273	
274	    FUNCTION = &quot;run&quot;
275	
276	    OUTPUT_NODE = False
277	
278	    CATEGORY = &quot;latent&quot;
279	
280	    def run(self, latent_image: clabc.Mapping[str, torch.Tensor],
281	            dup_times: int):
282	        &quot;&quot;&quot;
283	        对latent_image进行复制, 复制次数为dup_times。
284	        
285	        Args:
286	            latent_image (clabc.Mapping[str, torch.Tensor]): 输入的latent_image, 包含&#x27;samples&#x27;键。
287	            dup_times (int): 复制次数。
288	        
289	        Returns:
290	            Tuple[Dict[str, torch.Tensor]]: 返回包含samples的字典, samples是一个长度为(dup_times+1)的样本张量。
291	        
292	        &quot;&quot;&quot;
293	        samples = latent_image[&#x27;samples&#x27;]
294	
295	        sample_list = [samples] + [
</pre>
</div>


</div>
</div>

</div>

</body>
</html>
