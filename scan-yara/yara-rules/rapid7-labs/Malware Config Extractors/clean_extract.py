import sys
import pefile
import argparse


CHRARACTER_MAP = "00 80 40 C0 20 A0 60 E0 10 90 50 D0 30 B0 70 F0 08 88 48 C8 28 A8 68 E8 18 98 58 D8 38 B8 78 F8 04 84 44 C4 24 A4 64 E4 14 94 54 D4 34 B4 74 F4 0C 8C 4C CC 2C AC 6C EC 1C 9C 5C DC 3C BC 7C FC 02 82 42 C2 22 A2 62 E2 12 92 52 D2 32 B2 72 F2 0A 8A 4A CA 2A AA 6A EA 1A 9A 5A DA 3A BA 7A FA 06 86 46 C6 26 A6 66 E6 16 96 56 D6 36 B6 76 F6 0E 8E 4E CE 2E AE 6E EE 1E 9E 5E DE 3E BE 7E FE 01 81 41 C1 21 A1 61 E1 11 91 51 D1 31 B1 71 F1 09 89 49 C9 29 A9 69 E9 19 99 59 D9 39 B9 79 F9 05 85 45 C5 25 A5 65 E5 15 95 55 D5 35 B5 75 F5 0D 8D 4D CD 2D AD 6D ED 1D 9D 5D DD 3D BD 7D FD 03 83 43 C3 23 A3 63 E3 13 93 53 D3 33 B3 73 F3 0B 8B 4B CB 2B AB 6B EB 1B 9B 5B DB 3B BB 7B FB 07 87 47 C7 27 A7 67 E7 17 97 57 D7 37 B7 77 F7 0F 8F 4F CF 2F AF 6F EF 1F 9F 5F DF 3F BF 7F FF A8 5D 33 10 30 D0 04 10"


def relevant_encoded_data(data: list, sequence: str):
    position = data.find(sequence)
    if position != -1:
        return data[:position]
    else:
        return data


def get_encoded_data(pe: pefile.PE):
    filtered_list = []
    unique_string = "2EC6A676766FC6F4960E86"
    end_data = "0000000000000000000000000000000000000000000F"
    for section in pe.sections:
        if not ".data" in section.Name.decode("utf-8"):
            continue
        clean_data = section.get_data()
        unique_string = bytes.fromhex(unique_string)
        end_of_data = bytes.fromhex(end_data)
        find_encoded_content = clean_data.find(unique_string)
        extracted_data = clean_data[find_encoded_content:]
        find_ending = relevant_encoded_data(extracted_data, end_of_data)
        encoded_strings_list = find_ending.split(b"\x00")
        filtered_list = [item for item in encoded_strings_list if item]

        return filtered_list


def create_hex_list(input_string: str):
    chunks = [input_string[i : i + 2] for i in range(0, len(input_string), 2)]
    return chunks


def decode_data(encoded_data: list, char_map: str):
    decoded = []

    character_maps = char_map.split(" ")
    index_of_useless_data = None
    length_of_data = len(encoded_data)
    # if the encoded data is odd, find index_of_useless_data
    if length_of_data % 2 != 0:
        index_of_useless_data = length_of_data // 2

    for index, item in enumerate(reversed(encoded_data)):
        if index == index_of_useless_data:
            found_item = item
        else:
            decimal_converted = int(item, 16)
            found_item = character_maps[decimal_converted]
        decoded.append(found_item)

    decoded_str = "".join(decoded)
    bytes_object = bytes.fromhex(decoded_str)

    # Decode bytes to ASCII string
    ascii_string = bytes_object.decode("ascii")
    return ascii_string


def init_argparse():
    parser = argparse.ArgumentParser(description="Decode strings!")
    parser.add_argument(
        "dll_path",
        action="store",
        metavar="Path to DLL",
        help="Please provide path to the .dll file",
    )
    arguments = parser.parse_args()
    return arguments


if __name__ == "__main__":
    arguments = init_argparse()
    cleanup_bin_path = arguments.dll_path
    with open(cleanup_bin_path, "rb") as file:
        file_data = file.read()
    pe = pefile.PE(data=file_data)
    encoded_data = get_encoded_data(pe)

    for item in encoded_data:
        new_item = item.hex()
        new_spaced_hex = create_hex_list(new_item)
        # print(new_spaced_hex)
        decoded_data = decode_data(new_spaced_hex, char_map=CHRARACTER_MAP)
        print(decoded_data)
