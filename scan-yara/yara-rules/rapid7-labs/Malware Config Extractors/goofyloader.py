#
#   Author: Tyler McGraw
#   Company: Rapid7
#   Description: An extractor for malicious DLLs observed in distribution as part of a malvertising campaign.
#
import sys
import shutil
import pefile
import re
import os
import base64
from hashlib import md5
from Crypto.Cipher import AES

if (len(sys.argv) != 2):
    print('[!] Error: Invalid arguments.\n\tUsage: python goofyloader.py ~\malware.dll\nPress enter to exit...')
    input()
    exit()

input_file_path = sys.argv[1]
output_folder = re.sub(r'(?<=\\).*?$', r'goofydump', input_file_path)
python_loader = r'systemd\.py'
beacon_ext = r'\.aes'
pe = pefile.PE(input_file_path)

# Retrieve the encrypted resource and rdata section from the DLL
for section in pe.sections:
    if (re.search(r'\.rdata', str(section.Name))):
        rdata_md5 = section.get_hash_md5()
        rdata_size = section.SizeOfRawData
        rdata_offset = section.PointerToRawData
output_folder += '_' + rdata_md5 + '\\' # Assemble unique dump folder on a per sample basis
rdata = pe.get_memory_mapped_image()[rdata_offset:rdata_offset+rdata_size]
print('[+] .rdata loaded with size ' + str(rdata_size))
print('\tPreview: ' + rdata[0:16].hex(' ', 1))

for rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:
    for entry in rsrc.directory.entries:
        if (entry.directory.entries[0].data.struct.Size > 10000000):
            encrypted_rsrc_size = entry.directory.entries[0].data.struct.Size
            rsrc_offset = entry.directory.entries[0].data.struct.OffsetToData
encrypted_rsrc = pe.get_memory_mapped_image()[rsrc_offset:rsrc_offset+encrypted_rsrc_size]
print('[+] Resource loaded with size ' + str(encrypted_rsrc_size))
print('\tPreview: ' + encrypted_rsrc[0:16].hex(' ', 1))

# Retrieve AES-256 key and iv from the DLL
aes_blob = re.search(r'(?<=00)[0-9a-z]{96}', str(rdata))
rdata_key_offset = aes_blob.start(0)
aes_blob = aes_blob.group(0)
aes_iv = aes_blob[0:32]
aes_key = aes_blob[32:96]
print('[+] AES-256 key found at .rdata offset: ' + str(rdata_key_offset))
print('\tIV: ' + aes_iv)
print('\tKey: ' + aes_key)

# Decrypt the resource
print('\nDecrypting the resource...\n')
cipher = AES.new(bytes.fromhex(aes_key), AES.MODE_CBC, bytes.fromhex(aes_iv))
rsrc_zip = cipher.decrypt(encrypted_rsrc)
print('[+] Resource decrypted.')
print('\tPreview: ' + rsrc_zip[0:16].decode('cp437'))
if (rsrc_zip[0:2].hex() != '504b'): # Check magic bytes of result
    print('\n\t[!] Decryption did not return a zip archive. Exiting...')
    exit()
    
# Write output
decrypted_zip_name = 'decrypted_resource.zip'
abspath_outputzip1 = os.path.abspath(output_folder) + '\\' + decrypted_zip_name
print('\tThe decrypted archive will be saved to: "' + abspath_outputzip1 + '"')
if not os.path.exists(output_folder):
    os.mkdir(output_folder)
with open(abspath_outputzip1, 'wb+') as output:
    output.write(rsrc_zip)
print('[+] Archive saved.')

# Fetch python loader and encrypted beacon
print('\nProceeding to beacon retrieval...\n')
rsrc_output_folder = output_folder + 'decrypted_resource\\'
shutil.unpack_archive(abspath_outputzip1, rsrc_output_folder)
rsrc_files = os.listdir(rsrc_output_folder)

for file in rsrc_files:
    if (re.search(r'\.zip$', file)):
        staging_zip = rsrc_output_folder + file
        break;
if (not staging_zip):
    print('\n\t[!] No zip archive found in ' + rsrc_output_folder)
    exit()
staging_output_folder = staging_zip.replace('.zip', '\\')
shutil.unpack_archive(staging_zip, staging_output_folder)

staging_files = os.listdir(staging_output_folder)
if (len(staging_files) == 1 and os.path.isdir(staging_output_folder + staging_files[0] + '\\')):
    staging_folder = staging_output_folder + staging_files[0] + '\\'
    print('\tAttempting to retrieve the beacon from "' + staging_folder + '"')

staging_files = os.listdir(staging_folder)
for file in staging_files:
    if (re.search(python_loader, file)):
        py_path = staging_folder + file
        print('[+] Python loader found: ' + py_path)
    if (re.search(beacon_ext, file)):
        beacon_crypt_path = staging_folder + file
        print('[+] Encrypted beacon found: ' + beacon_crypt_path)

# Retrieve AES key and IV from python loader
nested_content = 0 
with open(py_path, 'rb') as file:
    script = file.read()
with open(beacon_crypt_path, 'rb') as file:
    beacon_crypt = file.read()

py_iv = re.search(r'(?<=iv = b").*?(?=")', str(script))
py_key = re.search(r'(?<=key = b").*?(?=")', str(script))
    
if (py_key and py_iv):
    print('[+] Beacon AES IV found: ' + py_iv.group(0))
    py_iv = base64.b64decode(py_iv.group(0))
    print('[+] Beacon AES key found: ' + py_key.group(0))
    py_key = base64.b64decode(py_key.group(0))
else:
    print('\n\t[!] The AES key/IV was not found in ' + py_path)
    
    # Search for nested python script variant
    print('\n\tAttempting to process nested python script... ')
    nested_content = 1
    strtohash = re.search(r'(?<= ")[a-z]{6,32}(?=")', str(script))
    nested_script = re.search(r'(?<= ")[A-Za-z0-9\+/=]{1000,}(?=")', str(script))
    if (strtohash and nested_script):
        print('[+] Data found. Processing...')
    else:
        print('[-] Unknown variant. Exiting...')
        exit()
        
    hash_aes_key = md5(strtohash.group(0).encode('utf8')).digest()
    print('[+] AES key found for the nested python script: ' + str(hash_aes_key))
    junk_iv = b'\xa3\x16\x02\x99\xb6\x78\xcf\x4b\xe8\x7c\x54\xd9\x50\x08\x94\x07'
    cipher = AES.new(hash_aes_key, AES.MODE_CBC, junk_iv)
    script = cipher.decrypt(base64.b64decode(nested_script.group(0)))[16:]
    
    py_path = py_path.replace('.py', '2.py')
    print('\tThe decrypted python script will be saved to: "' + py_path + '"')
    with open(py_path, 'wb+') as output:
        output.write(script)
    print('[+] Nested python script decrypted and saved.\n')
   
# Recurse once if nested python script
if (nested_content):
    py_iv = re.search(r'(?<=iv = b").*?(?=")', str(script))
    py_key = re.search(r'(?<=key = b").*?(?=")', str(script))
    
    if (py_key and py_iv):
        print('[+] Beacon AES IV found: ' + py_iv.group(0))
        py_iv = base64.b64decode(py_iv.group(0))
        print('[+] Beacon AES key found: ' + py_key.group(0))
        py_key = base64.b64decode(py_key.group(0))
    else:
        print('\n\t[!] The AES key/IV was not found in ' + py_path)
        exit()
    
# Decrypt the beacon
print('\nDecrypting the beacon...\n')
cipher = AES.new(py_key, AES.MODE_CBC, py_iv)
beacon = cipher.decrypt(beacon_crypt)
print('[+] Beacon decrypted.')
print('\tPreview: ' + beacon[0:16].decode('cp437'))
if (beacon[0:2].hex() != '4d5a'): # Check magic bytes of result
    print('\n\t[!] Decryption did not return a valid PE file. Exiting...')
    exit()

# Write decrypted beacon
decrypted_beacon_name = 'beacon.dll'
abspath_output_beacon = os.path.abspath(output_folder) + '\\' + decrypted_beacon_name
print('\tThe decrypted archive will be saved to: "' + abspath_output_beacon + '"')
with open(abspath_output_beacon, 'wb+') as output:
    output.write(beacon)
print('[+] Archive saved.')

print('\t\n[-] Fully processed. Exiting.')
