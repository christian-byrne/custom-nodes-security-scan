from pathlib import Path
import argparse
import lznt1

STARTING_HEX_STRING = '49444154C6A579EA'
TARGET_BYTE = '49444154'

DEFAULT_OUTPUT_PATH  = Path.home().joinpath('IDAT Loader Output')

if not DEFAULT_OUTPUT_PATH.exists():
    DEFAULT_OUTPUT_PATH.mkdir(exist_ok=True)


def run():
    args = init_argparse()
    encryted_file = args.file
    output_path = args.output
    starting_hex_string = args.starting_hex_string
     # Searching for the IDAT string followed by known hex values C6 A5 79 EA
    extracted_data = extract_data_between_hex_strings(encryted_file, starting_hex_string)
    if extracted_data is None:
        exit("Please submit another file.")

    config_xor_key, relevant_data_size, final_data = extract_relevant_data_stage_one(TARGET_BYTE, extracted_data)

    print(f"Found XOR Key: {config_xor_key.hex()}")
    print(f"Found Config Size: {relevant_data_size.hex()}")

    # Functions below find decompressed data
    xor_data = xor(final_data, config_xor_key)
    decompressed_data = lznt1.decompress(xor_data)

    idat_decompressed_path = output_path.joinpath('IDAT_decompressed_payload.bin')
    idat_decompressed_msg = f'IDAT decompressed payload has been written to {idat_decompressed_path}'
    write_file_in_bytes(idat_decompressed_path,decompressed_data,optional_verbal_string=idat_decompressed_msg)

    # Functions below find second stage encrypted bytes
    final_payload_encrypted_bytes = extract_data_stage_two(decompressed_data)

    # Final Functions will decrypt data and dump final payload
    final_payload_decrypted = extract_final_payload(xor, final_payload_encrypted_bytes)

    idat_final_payload_path = output_path.joinpath('IDAT_final_payload.bin')
    idat_final_msg = f'IDAT Final Payload has been written to {idat_final_payload_path}'
    write_file_in_bytes(idat_final_payload_path, final_payload_decrypted,optional_verbal_string=idat_final_msg)


def extract_data_between_hex_strings(encrpyted_file, start_hex_string):
    content = encrpyted_file.read()
    start_bytes = bytes.fromhex(start_hex_string)
    start_index = content.find(start_bytes)
    if start_index == -1:
        print("Start or end hex string not found in the file.")
        return None
    extracted_data = content[start_index + len(start_bytes):]
    return extracted_data


def find_and_remove_bytes(data_relevant, target_byte_string):
    target_bytes = bytes.fromhex(target_byte_string)
    index = data_relevant.find(target_bytes)

    while index != -1:
        start_index = max(0, index - 8)
        end_index = index + len(target_bytes)
        data_relevant = data_relevant[:start_index] + data_relevant[end_index:]
        index = data_relevant.find(target_bytes)

    return data_relevant


def xor(data,key):
    out = []
    for index, item in enumerate(data):
        out.append(item ^ key[index % len(key)])
    return bytes(out)


def init_argparse():
    parser = argparse.ArgumentParser(
                    prog='IDAT_Loader extractor',
                    description='Decrpyts the final payload from IDAT Loader')
    parser.add_argument('file', type=argparse.FileType('rb'), help='Please submit the path to the finaly payload from IDAT Loader')
    parser.add_argument('--starting_hex_string', default=STARTING_HEX_STRING, help='Please submit the path to the finaly payload from IDAT Loader')
    parser.add_argument('--target_byte', default=TARGET_BYTE, help='Please submit the path to the finaly payload from IDAT Loader')
    parser.add_argument('--output', default=DEFAULT_OUTPUT_PATH, help='Please submit the path to the finaly payload from IDAT Loader')
    args = parser.parse_args()
    return args


def extract_relevant_data_stage_one(target_byte, extracted_data):
    config_xor_key = extracted_data[:4]
    relevant_data_size = extracted_data[4:7][::-1]
    size_to_read = int.from_bytes(relevant_data_size, "big")
    relevant_data = extracted_data[12:]
    relevant_data = find_and_remove_bytes(relevant_data, target_byte)
    final_data = relevant_data[:size_to_read]
    return config_xor_key, relevant_data_size, final_data


def extract_data_stage_two(decompressed_data):
    second_stage_location = decompressed_data[8:10][::-1]
    second_stage_size_to_read = int.from_bytes(second_stage_location, "big") + 989
    second_stage_data = decompressed_data[second_stage_size_to_read:]
    final_payload_location = int.from_bytes(second_stage_data[3820:3823][::-1], "big") + 3812 #IDAT Loader searches for encrypted bytes using "+ offset of EE4"
    final_payload_encrypted_bytes = second_stage_data[final_payload_location:]
    return final_payload_encrypted_bytes


def extract_final_payload(xor, final_payload_encrypted_bytes):
    final_payload_xor_key = final_payload_encrypted_bytes[:200]
    final_payload_bytes = final_payload_encrypted_bytes[200:]
    final_payload_decrypted = xor(final_payload_bytes,final_payload_xor_key)
    return final_payload_decrypted


def write_file_in_bytes(file_path, data,optional_verbal_string=None):
    with open(file_path, 'wb') as file:
        file.write(data)
    if optional_verbal_string:
        print(optional_verbal_string)


if __name__ == "__main__":
    run()

